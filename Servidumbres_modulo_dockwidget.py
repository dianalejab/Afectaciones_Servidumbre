# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Afectaciones_servidumbresDockWidget
                                 A QGIS plugin
 Este plugin permite determinar las afectaciones prediales que conlleva un proyecto de sismica
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-05-05
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Diana Alejandra Bocanegra
        email                : bocanegra.pataquiva.diana@usal.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import qgis.core
from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtWidgets import QMessageBox
from qgis import processing


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Servidumbres_modulo_dockwidget_base.ui'))


class Afectaciones_servidumbresDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(Afectaciones_servidumbresDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect



        self.setupUi(self)

        #se cargan las rutas de los elementos seleccinados y se agrega un filtro para la extension de los archivos
        self.btn_cargar.clicked.connect(self.cargar_datos)
        self.qfw_infra.setFilter("Archivos shp (*.shp)")
        self.qfw_predial.setFilter("Archivos shp (*.shp)")
        self.qfw_cobert.setFilter("Archivos shp (*.shp)")
        self.qfw_jurcat.setFilter("Archivos csv (*.csv)")

        self.btn_procesar.clicked.connect(self.procesar_datos) #Boton procesar datos
        self.btn_capapredial.clicked.connect(self.capa_predial)
        self.btn_capaproyec.clicked.connect(self.capa_proyecto)
        self.btn_tabla.clicked.connect(self.exportar_atributos)
        self.btn_atripredial.clicked.connect(self.pasopredial)
        self.btn_atriproyec.clicked.connect(self.pasoproyec)
        self.btn_atritabla.clicked.connect(self.pasotabla)
        self.btn_limpiar.clicked.connect(self.limpiar)


    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def cargar_datos(self, event):
        ruta=str(self.qfw_infra.filePath())
        ruta1=str(self.qfw_cobert.filePath())
        ruta2=str(self.qfw_predial.filePath())
        ruta3 = str(self.qfw_jurcat.filePath())

        QMessageBox.information(self,"Capas cargadas","Archivo seleccionado: "+ruta+ruta1+ruta2+ruta3)

    def procesar_datos(self,event):

        #se crea la variable para almacenar la distancia del buffer
        dist = float(self.qle_buffer.text())

        #se llaman los ficheros seleccionados

        layer = qgis.core.QgsVectorLayer(str(self.qfw_infra.filePath()), "Infraestructura", "ogr")
        layer1= qgis.core.QgsVectorLayer(str(self.qfw_cobert.filePath()), "Cobertura", "ogr")
        layer2 = qgis.core.QgsVectorLayer(str(self.qfw_predial.filePath()), "Predial", "ogr")
        tabla = qgis.core.QgsVectorLayer(str(self.qfw_jurcat.filePath()), "Juridico-Catastral", "ogr")


        #se crea el buffer a partir de las lineas de infraestructura, se determina un estilo de terminacion plana

        buffer = processing.run("native:buffer", {'INPUT': layer,
                                                  'DISTANCE': dist,
                                                  'END_CAP_STYLE': 1,
                                                  'OUTPUT': 'E:/afectacion.shp'})

        afectacion = qgis.core.QgsVectorLayer('E:/afectacion.shp')

        # qgis.core.QgsProject.instance().addMapLayer(afectacion)

        # se genera una interseccion entre la capa de cobertura y el area de afectacion
        intersect = processing.run("native:intersection", {'INPUT': layer1,
                                                           'OVERLAY': afectacion,
                                                           'OUTPUT': 'E:/cobert_predial.shp'})
        afecobert = qgis.core.QgsVectorLayer('E:/cobert_predial.shp')

        #se disuelve a partir del nombre de la cobertura a partir del atributo name
        dissolve = processing.run("native:dissolve", {'INPUT': afecobert,
                                                  'FIELD': 'Name',
                                                  'OUTPUT': 'E:/afect_cobert.shp'})
        disolcobert = qgis.core.QgsVectorLayer('E:/afect_cobert.shp')

        #se realiza la interseccion entre la afectacion de cobertura, con la capa predial

        interpredial = processing.run("native:intersection", {'INPUT': disolcobert,
                                                              'OVERLAY': layer2,
                                                              'OUTPUT': 'E:/afect_pred.shp'})
        afecpredial = qgis.core.QgsVectorLayer('E:/afect_pred.shp')

        # se disuelve a partir del tipo de cobertura y la cedula catastral

        union_f = processing.run("native:dissolve", {'INPUT': afecpredial,
                                                     'FIELD': ['Name', 'CEDULA_CAT'],
                                                     'OUTPUT': 'E:/pred_cobert.shp'})

        dissolve_afectpredial= qgis.core.QgsVectorLayer('E:/pred_cobert.shp')

        # calculamos el área de afectacion por cobertura

        area_afect = processing.run("qgis:fieldcalculator", {'INPUT':dissolve_afectpredial, 'FIELD_NAME': 'Area(m2)',
                                                             'FIELD_TYPE': 0, 'FIELD_LENGTH': 10, 'FIELD_PRECISION': 2,
                                                             'NEW_FIELD': True, 'FORMULA': ' $area',
                                                             'OUTPUT': 'E:/geom_afect.shp'})

         # se realiza el join entre el archivo csv que se subio y la capa predial

        join= processing.run("native:joinattributestable",{'INPUT':layer2,'FIELD':'CEDULA_CAT',
                                                           'INPUT_2':tabla, 'FIELD_2':'CEDULA_CAT',
                                                           'OUTPUT':'E:/join.shp'})

        predial = qgis.core.QgsVectorLayer('E:/join.shp')

        #se agrega los atributos a cada list view

        for atrib in predial.fields():
            self.qlv_predial.addItem(atrib.name())
            self.qlv_proyec.addItem(atrib.name())
            self.qlv_tabla.addItem(atrib.name())

        ##activar los botones hasta que se procese la información ingresada

            self.btn_capaproyec.setEnabled(True)
            self.btn_tabla.setEnabled(True)
            self.btn_capapredial.setEnabled(True)
            self.btn_limpiar.setEnabled(True)

    #se pasa los atributos seleccionados a la otra ventana

    def pasopredial(self,event):
        self.qlv_selectpredial.addItem(self.qlv_predial.currentItem().text())

    def pasoproyec(self,event):

        atributos=self.qlv_selectproyec.addItem(self.qlv_proyec.currentItem().text())

    def pasotabla (self,event):
        self.qlv_selecttabla.addItem(self.qlv_tabla.currentItem().text())

    def capa_predial(self,event):

        #se recorre toda la seleccion que se realiza en la ventana qlv.selectpredial y se eliminan los campos seleccionados
        #estos campos se eliminan de el shapefile join y se genera una nueva capa llamada predial

        atribpredial = qgis.core.QgsVectorLayer('E:/join.shp')

        colum = "["

        nom_camp = []

        for contar in range(self.qlv_selectpredial.count()):

            nom_camp.append(self.qlv_selectpredial.item(contar).text())

            if colum != "[":

                colum = colum + ",'" + str(self.qlv_selectpredial.item(contar).text()) + "'"

            else:
                colum = colum + "'" + str(self.qlv_selectpredial.item(contar).text()) + "'"

        colum = colum + "]"

        camp_delete = []

        for camp in atribpredial.dataProvider().fields():
            if camp.name() in nom_camp:
                camp_delete.append(atribpredial.dataProvider().fieldNameIndex(camp.name()))

        atribpredial.dataProvider().deleteAttributes(camp_delete)
        atribpredial.updateFields()

        salpred = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(atribpredial, 'E:/predial.shp', "CP1250",
                                                                    atribpredial.crs(), driverName="ESRI Shapefile")

        # de acuerdo al numero que se ingrese en qle_cedcat se extraer los atributos de ese identificados en la capa rpedial y coberturas

        ced = (self.qle_cedcat.text())

        shapecobert = qgis.core.QgsVectorLayer('E:/geom_afect.shp')
        selectcobert = processing.run("native:extractbyattribute",{'INPUT': shapecobert, 'FIELD': 'CEDULA_CAT',
                                                                   'OPERATOR': 0, 'VALUE': ced, 'OUTPUT': 'E:/cob_afec.shp'})

        atribpredio = qgis.core.QgsVectorLayer('E:/predial.shp')
        selectpredial = processing.run("native:extractbyattribute",
                                {'INPUT': atribpredio, 'FIELD': 'CEDULA_CAT',
                                 'OPERATOR': 0, 'VALUE': ced, 'OUTPUT': 'E:/predio.shp'})

        predio = qgis.core.QgsVectorLayer('E:/predio.shp', 'Predio')
        capapredio = qgis.core.QgsProject.instance().addMapLayers([predio])

        coberpredial = qgis.core.QgsVectorLayer('E:/cob_afec.shp', 'Cobertura-Predial')
        capacobper = qgis.core.QgsProject.instance().addMapLayers([coberpredial])

        # 206140001000000030065000000000

    def capa_proyecto(self,event):

        # se recorre toda la seleccion que se realiza en la ventana qlv.selectproyec y se eliminan los campos seleccionados
        # estos campos se eliminan de el shapefile join y se genera una nueva capa llamada predial_proyecto

        proyec_afect = qgis.core.QgsVectorLayer('E:/join.shp')

        column1 = "["

        nombres_campos_proy = []

        for contar in range(self.qlv_selectproyec.count()):

            nombres_campos_proy.append(self.qlv_selectproyec.item(contar).text())

            if column1 != "[":

                column1 = column1 + ",'" + str(self.qlv_selectproyec.item(contar).text()) + "'"

            else:
                column1 = column1 + "'" + str(self.qlv_selectproyec.item(contar).text()) + "'"

        column1 = column1 + "]"

        camp_borrar = []

        for campo_1 in proyec_afect.dataProvider().fields():
            if campo_1.name() in nombres_campos_proy:
                camp_borrar.append(proyec_afect.dataProvider().fieldNameIndex(campo_1.name()))

        proyec_afect.dataProvider().deleteAttributes(camp_borrar)
        proyec_afect.updateFields()

        proyectof = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(proyec_afect, 'E:/predial_proyecto.shp', "CP1250",
                                                                      proyec_afect.crs(), driverName="ESRI Shapefile")

        pro = qgis.core.QgsVectorLayer('E:/predial_proyecto.shp','Predial_Proyecto')
        qgis.core.QgsProject.instance().addMapLayers([pro])
        coberproyec=qgis.core.QgsVectorLayer('E:/geom_afect.shp','Coberturas-Afectacion')
        capa=qgis.core.QgsProject.instance().addMapLayers([coberproyec])

    def exportar_atributos(self,event):

        # se recorre toda la seleccion que se realiza en la ventana qlv.selecttabla y se eliminan los campos seleccionados
        # estos campos se eliminan y se genera un archivo csv llamado export

        afectaciones = qgis.core.QgsVectorLayer('E:/join.shp')

        columnas = "["

        nombres_campos = []

        for cont in range(self.qlv_selectproyec.count()):

            nombres_campos.append(self.qlv_selectproyec.item(cont).text())

            if columnas != "[":

                columnas = columnas + ",'" + str(self.qlv_selectproyec.item(cont).text()) + "'"

            else:
                columnas = columnas + "'" + str(self.qlv_selectproyec.item(cont).text()) + "'"

        columnas = columnas + "]"

        campos_borrar = []

        for campo in afectaciones.dataProvider().fields():
            if campo.name() in nombres_campos:
                campos_borrar.append(afectaciones.dataProvider().fieldNameIndex(campo.name()))

        afectaciones.dataProvider().deleteAttributes(campos_borrar)
        afectaciones.updateFields()

        fichero = open('E:/export.csv', 'w')

        for feature in afectaciones.getFeatures():
            valor = ""
            for campos in afectaciones.dataProvider().fields():

                if valor == "":
                    valor = str(feature[campos.name()])
                else:
                    valor = valor + ";" + str(feature[campos.name()])
            fichero.write(valor)
            fichero.write('\n')
        fichero.close()

    def limpiar(self,event):

        self.qle_buffer.clear()
        self.qle_cedcat.clear()
        self.qlv_selectpredial.clear()
        self.qlv_selectproyec.clear()
        self.qlv_selecttabla.clear()
        self.qlv_predial.clear()
        self.qlv_proyec.clear()
        self.qlv_tabla.clear()